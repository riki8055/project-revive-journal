# Day 1 â€” Architecture First _(No Coding)_

## Objectives

> Build a clear, explainable mental model of the Note-Taking App before touching the keyboard.

## 1ï¸âƒ£ Problem Definition _(Engineering, not features)_

**Problem statement _(strict)_:**

> A user can create, view, and delete notes. <br>
> Notes must survive frontend refresh. <br>
> System must tolerate bad inputs and unreliable network.

No UI fantasy. No styling talk. Only behavior.

## 2ï¸âƒ£ System Boundary Definition _(MOST IMPORTANT)_

Draw this line in your head ğŸ‘‡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend   â”‚  HTTP  â”‚    Backend    â”‚
â”‚  (Browser)   â”‚ <â”€â”€â”€>  â”‚   (Node.js)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Frontend is responsible for:

- User interaction
- Rendering notes
- Calling APIs
- Handling failures visually

### Backend is responsible for:

- Accepting requests
- Validating data
- Storing notes
- Returning responses

ğŸš« Frontend must **never**:

- Decide note IDs
- Assume data validity
- Guess backend state

ğŸš« Backend must **never**:

- Care about DOM
- Care about user clicks
- Assume UI correctness

This separation is sacred.

## 3ï¸âƒ£ Data Contract _(Single Source of Truth)_

This is the **contract**, not an implementation.

```js
Note {
  id: string,
  title: string,
  content: string,
  createdAt: number
}
```

### Rules:

- `id` generated by backend
- `createdAt` generated by backend
- Frontend treats notes as **immutable** snapshots

This avoids sync hell later.

## 4ï¸âƒ£ API Surface _(Minimal but Complete)_

We define **what exists**, not how itâ€™s coded.

| Method | Route      | Purpose                 |
| ------ | ---------- | ----------------------- |
| GET    | /notes     | Fetch all notes         |
| POST   | /notes     | Create a new note       |
| PUT    | /notes/:id | Update an existing note |
| DELETE | /notes/:id | Delete a note           |
| GET    | /health    | Server health check     |

### Example request _(POST /notes)_

```json
{
  "title": "Meeting Notes",
  "content": "Discussed architecture"
}
```

### Example response

```json
{
  "id": "n_123",
  "title": "Meeting Notes",
  "content": "Discussed architecture",
  "createdAt": 1700000000000
}
```

### ğŸ” Update Note â€” Contract Definition

Request

**PUT /notes/:id**

```json
{
  "title": "Updated meeting notes",
  "content": "Architecture finalized"
}
```

Rules:

- id comes only from URL
- Body contains only mutable fields
- Missing fields â†’ validation failure
- Partial updates are not allowed _(no PATCH yet)_

### Why PUT and not PATCH?

> Because this keeps state transitions **explicit and predictable** in a learning system.

### Response _(Success)_

```json
{
  "id": "n_123",
  "title": "Updated meeting notes",
  "content": "Architecture finalized",
  "createdAt": 1700000000000
}
```

Backend guarantees:

- `id` unchanged
- `createdAt` unchanged
- Full note returned _(single source of truth)_

### Failure Scenarios _(Defined, not coded yet)_

| Case                  | Response                  |
| --------------------- | ------------------------- |
| Invalid JSON          | 400 Bad Request           |
| Missing title/content | 422 Unprocessable Entity  |
| Note not found        | 404 Not Found             |
| Server error          | 500 Internal Server Error |

These are **contracts**, not implementation details.

Backend owns **structure**. Frontend obeys.

### Why This Addition Is Architecturally Correct

âœ” Maintains **clear state transitions** <br>
âœ” Preserves **backend authority** <br>
âœ” Avoids frontend guesswork <br>
âœ” Prepares for failure training later _(Week 6)_

## 5ï¸âƒ£ Data Flow _(One Direction Only)_

Golden Rule:

> Data flows down. Events flow up.

```
User Action
   â†“
Frontend Controller
   â†“
API Client
   â†“
Backend
   â†“
Response
   â†“
State Update
   â†“
UI Render
```

ğŸš« No shortcut DOM updates <br>
ğŸš« No UI mutating data directly

This is **React thinking without React**.

## 6ï¸âƒ£ Internal Module Boundaries _(Mental Map)_

Youâ€™re not coding, but you must **see files in your head**.

### Frontend _(conceptual)_

```
/frontend
  â”œâ”€â”€ ui            â†’ render only
  â”œâ”€â”€ state         â†’ data only
  â”œâ”€â”€ api           â†’ fetch only
  â”œâ”€â”€ controller    â†’ glue logic
```

### Backend _(conceptual)_

```
/backend
  â”œâ”€â”€ server        â†’ HTTP only
  â”œâ”€â”€ routes        â†’ URL â†’ action
  â”œâ”€â”€ services      â†’ business logic
  â”œâ”€â”€ store         â†’ data storage
  â”œâ”€â”€ logger        â†’ observability
```

Each layer knows **only one layer below it**.

## 7ï¸âƒ£ Failure as a First-Class Citizen _(Preview)_

Even today, list what can break:

- Network timeout
- Invalid JSON
- Empty request body
- Server crash
- Partial response

We are **not fixing them today**, only acknowledging reality.

## 8ï¸âƒ£ Observability Philosophy _(Before Logs Exist)_

Define what must be observable later:

### Frontend:

- API call start
- API call end
- Failure reason

### Backend

- Incoming request
- Validation failure
- Processing time
- Crash cause

If something fails silently â†’ architecture failed.

## 9ï¸âƒ£ Day-1 Deliverables _(Non-Negotiable)_

By end of Day 1, you should have:

âœ… A hand-drawn or markdown architecture diagram <br>
âœ… A written data contract <br>
âœ… A list of API routes <br>
âœ… Clear ownership rules _(frontend vs backend)_ <br>
âœ… A sentence explaining data flow

If you canâ€™t explain this to someone else â€” **do not code tomorrow**.

## Final Thought _(Important)_

Most developers skip this day.
Thatâ€™s why their apps become unmaintainable.

Youâ€™re doing what **senior engineers do instinctively**.

# Day 2 â€” Backend Skeleton

**Node.js Â· No frameworks Â· Reality-first**

## Objectives

> Build a minimal, observable HTTP server that you fully understand end-to-end.

## 0ï¸âƒ£ Ground Rules _(Read Before Coding)_

âŒ No Express / Fastify / frameworks <br>
âŒ No database <br>
âŒ No business logic yet <br>
âœ… Raw http module <br>
âœ… Manual routing <br>
âœ… Manual logging <br>
âœ… Explicit control over request & response

If something feels â€œverboseâ€, thatâ€™s the **point**.

## 1ï¸âƒ£ What We Are Building Today _(Scope Lock)_

By end of Day 2, backend will have:

- A running HTTP server
- One real route: `GET /health`
- One placeholder route: `GET /notes` â†’ returns `[]`
- A **manual logger**
- Clean separation:
  - HTTP layer
  - Routing
  - Logging

Nothing else

## 2ï¸âƒ£ Mental Model: What Happens on Every Request

Before code, internalize this:

```pgsql
Client
  â†“
TCP connection
  â†“
Node http server
  â†“
Request object (req)
  â†“
Your routing logic
  â†“
Response object (res)
  â†“
Serialized HTTP response
```

Node does **not**:

- Parse JSON automatically
- Route automatically
- Log automatically

You do everything.

## 3ï¸âƒ£ Folder Structure _(Minimal but Intentional)_

> commit hash **3a09b94**

Create this **exact structure**:

```pgsql
backend/
  â”œâ”€â”€ server.js
  â”œâ”€â”€ router.js
  â””â”€â”€ logger.js
```

Each file has **one responsibility**.

## 4ï¸âƒ£ logger.js â€” Observability Starts Here

> commit hash **287b26a**

> Logging is not debugging. <br>
> Logging is **system memory**.

```js
// logger.js

function log({ method, url, status, duration }) {
  const time = new Date().toISOString();

  console.log(`[${time}] ${method} ${url} ${status} ${duration}ms`);
}

module.exports = { log };
```

Why this shape?

- Structured
- Extendable
- No business coupling

## 5ï¸âƒ£ router.js â€” Manual Routing _(No Magic)_

> commit hash **87d846b**

> Routing is **just decision making**.

```js
// router.js

function router(req, res) {
  const { method, url } = req;

  if (method === "GET" && url === "/health") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ status: "ok" }));
    return;
  }

  if (method === "GET" && url === "/notes") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify([]));
    return;
  }

  // fallback
  res.writeHead(404, { "Content-Type": "application/json" });
  res.end(JSON.stringify({ error: "Not Found" }));
}

module.exports = { router };
```

Important:

- `return` after response â†’ **critical**
- Explicit headers â†’ no guessing
- No try/catch yet (we want it to break loudly)

## 6ï¸âƒ£ server.js â€” The HTTP Boundary

> commit hash **96f1b70**

This file **touches the network**. <br>
Everything else must stay pure.

```js
// server.js

const http = require("http");
const { router } = require("./router");
const { log } = require("./logger");

const PORT = 3000;

const server = http.createServer((req, res) => {
  const start = Date.now();

  res.on("finish", () => {
    const duration = Date.now() - start;

    log({
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration,
    });
  });

  router(req, res);
});

server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
```

Key ideas here:

- `res.on('finish')` â†’ **true response lifecycle**
- Logging happens after response is sent
- Server knows nothing about routes

This is **clean separation**.

## 7ï¸âƒ£ Test Like an Engineer _(Not a Coder)_

Use browser or curl.

### Health check

```bash
GET http://localhost:3000/health
```

Response:

```json
{ "status": "ok" }
```

Log:

```bash
[2026-01-19T15:12:01.234Z] GET /health 200 1ms
```

### Notes

```bash
GET http://localhost:3000/notes
```

Response:

```json
[]
```

### Invalid route

```bash
GET /random
```

response:

```json
{ "error": "Not Found" }
```

## 8ï¸âƒ£ What You Must _Feel_ After Day 2

If Day 2 worked correctly, you should now:

- Understand **how Express works internally**
- Know where latency is measured
- Know who controls headers & status codes
- Realize how much magic frameworks hide

If you donâ€™t feel this yet â†’ reread and retype manually.

## 9ï¸âƒ£ Common Mistakes _(Avoid These)_

âŒ Putting logic in `server.js` <br>
âŒ Logging before response finishes <br>
âŒ Forgetting `return` after `res.end()` <br>
âŒ Assuming JSON parsing exists <br>
âŒ Adding POST logic today (too early)

## 1ï¸âƒ£0ï¸âƒ£ Day 2 Exit Criteria _(Hard Check_)

You are allowed to proceed only if:

- You can explain every line in `server.js`
- You know why `res.on('finish')` is used
- You can add a new route **without copying blindly**
- Logs make sense without reading code

# Day 3 â€” Backend Data Layer _(Services & Separation of Concerns)_

**Services Â· Separation of Concerns Â· Controlled State**

## Objectives

> Move all note-related logic out of routing and into a dedicated service layer, while keeping HTTP handling dumb.

## 0ï¸âƒ£ Architectural Rule of the Day

> **Routes translate HTTP â†’ intent** <br> > **Services execute business logic** <br> > **Server knows nothing about notes**

If a route _decides_ anything â†’ itâ€™s doing too much.

## 1ï¸âƒ£ What Changes Today _(Scope Lock)_

By end of Day 3, backend will have:

- A **notes service** responsible for:

  - Creating notes
  - Reading notes

- In-memory storage _(array)_

- Routes that:

  - Delegate logic
  - Handle HTTP concerns only

- Logs that show:
  - When service logic runs
  - How long it takes

âŒ No persistence <br>
âŒ No POST body parsing errors handling yet _(comes Day 6)_

## 2ï¸âƒ£ Folder Structure _(Evolved, Still Minimal)_

> commit hash **db625b0**

Update backend structure to:

```markdown
backend/
â”œâ”€â”€ server.js
â”œâ”€â”€ router.js
â”œâ”€â”€ logger.js
â”œâ”€â”€ services/
â”‚ â””â”€â”€ notes.service.js
â””â”€â”€ store/
â””â”€â”€ notes.store.js
```

This is **separation by responsibility**, not by type.

## 3ï¸âƒ£ notes.store.js â€” Controlled State

> commit hash **ee9fc04**

State should be boring and predictable.

```js
// store/notes.store.js

const notes = [];

function getAll() {
  return notes;
}

function add(note) {
  notes.push(note);
  return note;
}

module.exports = {
  getAll,
  add,
};
```

Rules:

- No IDs generated here
- No timestamps here
- No HTTP here

Store only stores.

## 4ï¸âƒ£ notes.service.js â€” Business Logic Lives Here

> commit hash **95f1b65**

This is the **brain** of the backend.

```js
// services/notes.service.js

const store = require("../store/notes.store");

function createNote({ title, content }) {
  const note = {
    id: `n_${Date.now()}`,
    title,
    content,
    createdAt: Date.now(),
  };

  return store.add(note);
}

function getNotes() {
  return store.getAll();
}

module.exports = {
  createNote,
  getNotes,
};
```

Why here?

- ID generation = business decision
- Timestamp = business decision
- Data shape = business decision

## 5ï¸âƒ£ router.js â€” Routes Become Thin

> commit hash **64a86d3**

Now routing becomes **translation only**.

```js
const { createNote, getNotes } = require("./services/notes.service");

function router(req, res) {
  const { method, url } = req;

  if (method === "GET" && url === "/health") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ status: "ok" }));
    return;
  }

  if (method === "GET" && url === "/notes") {
    const notes = getNotes();
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify(notes));
    return;
  }

  if (method === "POST" && url === "/notes") {
    let body = "";

    req.on("data", (chunk) => {
      body += chunk.toString();
    });

    req.on("end", () => {
      const parsed = JSON.parse(body); // intentionally unsafe (for now)
      const note = createNote(parsed);

      res.writeHead(201, { "Content-Type": "application/json" });
      res.end(JSON.stringify(note));
    });

    return;
  }

  // fallback
  res.writeHead(404, { "Content-Type": "application/json" });
  res.end(JSON.stringify({ error: "Not Found" }));
}

module.exports = { router };
```

âš ï¸ We are **deliberately** not handling JSON errors yet. <br>
Failure training is coming.

## 6ï¸âƒ£ Logging Service Execution _(Observability Upgrade)_

> commit hash **e49767a**

Modify `notes.service.js`:

```js
const store = require("../store/notes.store");

function createNote({ title, content }) {
  const start = Date.now();

  const note = {
    id: `n_${Date.now()}`,
    title,
    content,
    createdAt: Date.now(),
  };

  const result = store.add(note);

  console.log(`[SERVICE] createNote executed in ${Date.now() - start}ms`);

  return result;
}

function getNotes() {
  return store.getAll();
}

module.exports = {
  createNote,
  getNotes,
};
```

Later, this moves to a logger. <br>
Today, we just **see execution boundaries**.

## 7ï¸âƒ£ Test Like a System _(Not Just Endpoints)_

### Create a note

```bash
POST /notes
{
  "title": "Day 3",
  "content": "Separation of concerns"
}
```

Response:

```json
{
  "id": "n_170...",
  "title": "Day 3",
  "content": "Separation of concerns",
  "createdAt": 170...
}
```

Logs:

```bash
[SERVICE] createNote executed in 0ms
[2026-01-20T...] POST /notes 201 3ms
```

You now see:

- Business logic time
- HTTP lifecycle time

Thatâ€™s observability.

### [EXTRAS] How to Send a POST Request

#### âœ… Option 1: Using `Invoke-WebRequest`

```powershell
Invoke-WebRequest `
  -Uri http://localhost:3000/notes `
  -Method POST `
  -Headers @{ "Content-Type" = "application/json" } `
  -Body '{"title":"Day 3","content":"Separation of concerns"}'
```

or:

Using `curl`

```bash
curl -X POST http://localhost:3000/notes \
  -H "Content-Type: application/json" \
  -d '{"title":"Day 3","content":"Separation of concerns"}'
```

#### âœ… Option 2: Using Browser `fetch` _(Temporary Test)_

Open **Chrome DevTools â†’ Console** and paste:

```js
fetch("http://localhost:3000/notes", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    title: "From Browser",
    content: "Testing POST",
  }),
})
  .then((res) => res.json())
  .then(console.log)
  .catch(console.error);
```

This simulates **exactly what your frontend will do later**.

## 8ï¸âƒ£ What Youâ€™ve Actually Learned Today

Without realizing, you now understand:

- Why fat controllers are bad
- Why business logic must be testable without HTTP
- How databases fit later without rewriting routes
- Why microservices enforce service boundaries

You are **writing backend like a senior**, not a tutorial follower.

## 9ï¸âƒ£ Day 3 Exit Criteria (Non-Negotiable)

Proceed only if you can:

- Move storage to a file **without touching router**
- Add a new note field **without touching server.js**
- Explain why ID generation is not in the store
- Explain why routes are intentionally dumb

If not â€” stop and refactor.

# Day 4 â€” Frontend Skeleton

**Vanilla JS Â· UI â‰  Data Â· No Backend Yet**

## Objectives

> Build a frontend that can render notes **without knowing where they come from**.

If you do Day 4 correctly, plugging in the backend tomorrow will feel _boringly_ easy.

## 0ï¸âƒ£ Ground Rules _(Non-Negotiable)_

âŒ No fetch yet <br>
âŒ No backend calls <br>
âŒ No global mutable chaos <br>
âŒ No DOM manipulation from random places <br>
âœ… UI renders from state <br>
âœ… Events only request state changes

Think **React without React**.

## 1ï¸âƒ£ Mental Model First _(Read Slowly)_

```nginx
STATE  â†’  UI
EVENTS â†’  STATE
```

- UI never mutates data
- Events never touch DOM directly
- There is **one source of truth**

If you violate this today, youâ€™ll suffer on Day 5.

## 2ï¸âƒ£ Folder Structure _(Frontend Begins)_

> commit hash **3cd9dee**

Create this structure:

```matlab
frontend/
  â”œâ”€â”€ index.html
  â”œâ”€â”€ main.js
  â”œâ”€â”€ state/
  â”‚     â””â”€â”€ notes.state.js
  â”œâ”€â”€ ui/
  â”‚     â””â”€â”€ notes.ui.js
  â””â”€â”€ events/
        â””â”€â”€ notes.events.js
```

Each folder answers **one question**:

- `state` â†’ what data exists
- `ui` â†’ how data is shown
- `events` â†’ what user does

## 3ï¸âƒ£ index.html â€” Dumb HTML Only

> commit hash **2c5a74d**

HTML must be **boring**.

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Notes</title>
  </head>
  <body>
    <h1>Notes</h1>

    <form id="note-form">
      <input id="title" placeholder="Title" />
      <textarea id="content" placeholder="Content"></textarea>
      <button type="submit">Add</button>
    </form>

    <ul id="notes-list"></ul>

    <script type="module" src="./main.js"></script>
  </body>
</html>
```

âŒ No inline JS <br>
âŒ No logic in HTML

## 4ï¸âƒ£ notes.state.js â€” Single Source of Truth

> commit hash **27fe4de**

This replaces your database _(for now)_.

```js
// state/notes.state.js

let notes = [];

function getNotes() {
  return notes;
}

function setNotes(newNotes) {
  notes = newNotes;
}

function addNote(note) {
  notes = [...notes, note];
}

export { getNotes, setNotes, addNote };
```

Rules:

- No DOM
- No events
- No assumptions about backend

## 5ï¸âƒ£ notes.ui.js â€” Rendering Only

> commit hash **4ca0219**

UI is a **pure function of state**.

```js
// ui/notes.ui.js

import { getNotes } from "../state/notes.state.js";

const listEl = document.getElementById("notes-list");

function renderNotes() {
  const notes = getNotes();

  listEl.innerHTML = "";

  notes.forEach((note) => {
    const li = document.createElement("li");
    li.textContent = `${note.title}: ${note.content}`;
    listEl.appendChild(li);
  });
}

export { renderNotes };
```

UI does:

- Read state
- Paint DOM

Nothing else.

## 6ï¸âƒ£ notes.events.js â€” User Intent Only

> commit hash **a45f777**

Events **request changes**, they donâ€™t enforce them.

```js
// events/notes.event.js

import { addNote } from "../state/notes.state.js";
import { renderNotes } from "../ui/notes.ui.js";

const form = document.getElementById("note-form");

function initEvents() {
  form.addEventListener("submit", (e) => {
    e.preventDefault();

    const title = document.getElementById("title").value;
    const content = document.getElementById("content").value;

    addNote({
      id: Date.now(),
      title,
      content,
    });

    renderNotes();
    form.reset();
  });
}

export { initEvents };
```

Yes â€” weâ€™re generating IDs here **temporarily**. <br>
Weâ€™ll kill this tomorrow.

## 7ï¸âƒ£ main.js â€” The Glue _(Nothing Else)_

> commit hash **8c9cf48**

```js
// main.js

import { initEvents } from "./events/notes.events.js";
import { renderNotes } from "./ui/notes.ui.js";

initEvents();
renderNotes();
```

Thatâ€™s it. <br>
If `main.js` grows â†’ architecture failed.

## 8ï¸âƒ£ Test Like a Frontend Engineer

Open `index.html` in browser.

- Add notes
- Refresh page â†’ notes disappear _(expected)_
- UI updates only via `renderNotes()`

If UI changes **without calling render** â†’ bug.

## 9ï¸âƒ£ What Youâ€™ve Actually Learned Today

Without React, you just learned:

- State-driven UI
- Controlled data flow
- Why React exists
- Why DOM mutation sprawl is evil

Most people learn this **after** frameworks. <br>
You learned it **before**.

## ğŸ” Day 4 Exit Criteria

Youâ€™re ready only if:

- You can replace `addNote()` with API call tomorrow
- UI code never touches form inputs
- Events never touch DOM structure
- You understand why refresh loses data

# Day 5 â€” Frontend â†” Backend Communication

**Fetch Â· Data Flow Discipline Â· Zero Shortcut DOM Updates**

## Objectives

Connect frontend to backend **without breaking Day-4 architecture**.

Backend already exists. <br>
Frontend already exists. <br>
Today we **connect them without letting them leak into each other**.

## 0ï¸âƒ£ The One Rule You Must Not Break

> UI never talks to backend <br>
> Events never mutate UI directly <br>
> API never touches DOM

If you violate this once, stop and refactor.

## 1ï¸âƒ£ Updated Mental Model (Lock This In)

```pgsql
User Event
   â†“
Event Handler
   â†“
API Client (fetch)
   â†“
Backend
   â†“
Response
   â†“
State Update
   â†“
UI Render
```

âŒ No â€œjust update DOM quicklyâ€ <br>
âŒ No â€œIâ€™ll console.log and seeâ€ <br>
âŒ No â€œfetch inside UIâ€

## 2ï¸âƒ£ New Folder: API Layer _(This Is the Firewall)_

> commit hash **2fe244f**

Add a new folder:

```matlab
frontend/
  â”œâ”€â”€ api/
  â”‚     â””â”€â”€ notes.api.js
```

This file is the **only place** allowed to call `fetch`.

## 3ï¸âƒ£ notes.api.js â€” Backend Contract in Code

> commit hash **cf03445**

```js
// api/notes.api.js

const BASE_URL = "http://localhost:3000";

async function fetchNotes() {
  const res = await fetch(`${BASE_URL}/notes`);

  if (!res.ok) {
    throw new Error("Failed to fetch notes");
  }

  return res.json();
}

async function createNote({ title, content }) {
  const res = await fetch(`${BASE_URL}/notes`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ title, content }),
  });

  if (!res.ok) {
    throw new Error("Failed to create note");
  }

  return res.json();
}

export { fetchNotes, createNote };
```

Rules:

- No DOM
- No state
- No UI logic
- Only HTTP + JSON

## 4ï¸âƒ£ Update Events â€” This Is the Critical Change

> commit hash **a15600e**

### âŒ Old behavior

- Event â†’ addNote â†’ render

### âœ… New behavior

- Event â†’ API â†’ state â†’ render

Update `notes.events.js`:

```js
// events/notes.event.js

import { createNote } from "../api/notes.api.js";
import { addNote } from "../state/notes.state.js";
import { renderNotes } from "../ui/notes.ui.js";

const form = document.getElementById("note-form");

function initEvents() {
  form.addEventListener("submit", async (e) => {
    e.preventDefault();

    const title = document.getElementById("title").value;
    const content = document.getElementById("content").value;

    try {
      const createdNote = await createNote({ title, content });

      addNote(createdNote);
      renderNotes();
      form.reset();
    } catch (error) {
      alert("Failed to save note");
      console.error(error);
    }
  });
}

export { initEvents };
```

âš ï¸ Notice:

- Event handler is now `async`
- Backend owns ID + timestamp
- UI only re-renders after state update

## 5ï¸âƒ£ Load Notes on Page Load _(Initial Sync)_

> commit hash **fd6d29c**

Update `main.js`:

```js
// main.js

import { initEvents } from "./events/notes.events.js";
import { renderNotes } from "./ui/notes.ui.js";
import { setNotes } from "./state/notes.state.js";
import { fetchNotes } from "./api/notes.api.js";

async function initApp() {
  try {
    const notes = await fetchNotes();

    setNotes(notes);
    renderNotes();
  } catch (error) {
    alert("Failed to load notes");
    console.error(error);
  }

  initEvents();
}

initApp();
```

This is **frontend bootstrapping**.

## 6ï¸âƒ£ Test the Full System _(End-to-End)_

### Step 1

Start backend:

```nginx
node server.js
```

### Step 2

Open frontend (`index.html`)

### Step 3

Expected behavior:

- Existing notes load on refresh âœ…
- New note appears after submit âœ…
- IDs come from backend âœ…
- Logs show POST + GET âœ…

## 7ï¸âƒ£ Very Common Mistakes _(STOP IF YOU DO THESE)_

âŒ Calling fetch inside UI <br>
âŒ Updating DOM before API success <br>
âŒ Storing raw form values in state <br>
âŒ Letting frontend generate IDs <br>
âŒ Swallowing errors silently

If any of these exist â†’ refactor immediately.

## 8ï¸âƒ£ What You Just Achieved _(This Is Huge)_

You now have:

- Clear frontend â†” backend contract
- Predictable data flow
- Zero DOM-state desync
- Backend authority
- Replaceable backend _(tomorrow you could swap it)_

This is **framework-grade architecture** without a framework.

## ğŸ” Day 5 Exit Criteria _(Be Honest)_

Proceed only if you can say YES to all:

- Refreshing page reloads notes from backend
- Removing backend breaks app clearly
- No file violates its responsibility
- You can explain the full data flow aloud

## [optional] Browser Reality - CORS Policy!

CORS blocking is not a bug â€” this is the **browser doing its job**.

### â— What This Error REALLY Means

```pgsql
Access to fetch at 'http://localhost:3000/notes'
from origin 'http://localhost:5500'
has been blocked by CORS policy
```

**Translation:**

- Frontend is running on **origin A**

  `http://localhost:5500`

- Backend is running on **origin B**

http://localhost:3000

Browser says:

> _â€œHey JS, youâ€™re trying to talk cross-origin.
> I need explicit permission from the server.â€_

ğŸ‘‰ **CORS is a browser security rule**, not Node, not fetch, not your code.

> CORS is enforced by the browser, not the server

### âœ… The Fix _(Raw Node, No Libraries)_

> commit hash **1d4f0c5**

Update `server.js` in backend _(Minimal & Correct)_

```js
const http = require("http");
const { router } = require("./router");
const { log } = require("./logger");

const PORT = 3000;

const server = http.createServer((req, res) => {
  const start = Date.now();

  // âœ… CORS HEADERS (GLOBAL)
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");

  // âœ… Handle preflight requests
  if (req.method === "OPTIONS") {
    res.writeHead(204);
    res.end();
    return;
  }

  res.on("finish", () => {
    const duration = Date.now() - start;

    log({
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration,
    });
  });

  router(req, res);
});

server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
```

Why this works:

- Browser sends an **OPTIONS preflight**
- You respond cleanly
- Browser is satisfied
- Real request proceeds

> **Restart is Mandatory**
