# Day 1 â€” Architecture First _(No Coding)_

## Objectives

> Build a clear, explainable mental model of the Note-Taking App before touching the keyboard.

## 1ï¸âƒ£ Problem Definition _(Engineering, not features)_

**Problem statement _(strict)_:**

> A user can create, view, and delete notes. <br>
Notes must survive frontend refresh. <br>
System must tolerate bad inputs and unreliable network.

No UI fantasy. No styling talk. Only behavior.

## 2ï¸âƒ£ System Boundary Definition _(MOST IMPORTANT)_

Draw this line in your head ğŸ‘‡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend   â”‚  HTTP  â”‚    Backend    â”‚
â”‚  (Browser)   â”‚ <â”€â”€â”€>  â”‚   (Node.js)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Frontend is responsible for:

- User interaction
- Rendering notes
- Calling APIs
- Handling failures visually

### Backend is responsible for:

- Accepting requests
- Validating data
- Storing notes
- Returning responses

ğŸš« Frontend must **never**:

- Decide note IDs
- Assume data validity
- Guess backend state

ğŸš« Backend must **never**:

- Care about DOM
- Care about user clicks
- Assume UI correctness

This separation is sacred.

## 3ï¸âƒ£ Data Contract _(Single Source of Truth)_

This is the **contract**, not an implementation.

```js
Note {
  id: string,
  title: string,
  content: string,
  createdAt: number
}
```

### Rules:

- `id` generated by backend
- `createdAt` generated by backend
- Frontend treats notes as **immutable** snapshots

This avoids sync hell later.

## 4ï¸âƒ£ API Surface _(Minimal but Complete)_

We define **what exists**, not how itâ€™s coded.

| Method | Route      | Purpose                 |
|--------|------------|-------------------------|
| GET    | /notes     | Fetch all notes         |
| POST   | /notes     | Create a new note       |
| PUT    | /notes/:id | Update an existing note |
| DELETE | /notes/:id | Delete a note           |
| GET    | /health    | Server health check     |

### Example request _(POST /notes)_

```json
{
  "title": "Meeting Notes",
  "content": "Discussed architecture"
}
```

### Example response

```json
{
  "id": "n_123",
  "title": "Meeting Notes",
  "content": "Discussed architecture",
  "createdAt": 1700000000000
}
```

### ğŸ” Update Note â€” Contract Definition

Request

**PUT /notes/:id**

```json
{
  "title": "Updated meeting notes",
  "content": "Architecture finalized"
}
```

Rules:

- id comes only from URL
- Body contains only mutable fields
- Missing fields â†’ validation failure
- Partial updates are not allowed _(no PATCH yet)_

### Why PUT and not PATCH?

> Because this keeps state transitions **explicit and predictable** in a learning system.

### Response _(Success)_

```json
{
  "id": "n_123",
  "title": "Updated meeting notes",
  "content": "Architecture finalized",
  "createdAt": 1700000000000
}
```

Backend guarantees:

- `id` unchanged
- `createdAt` unchanged
- Full note returned _(single source of truth)_

### Failure Scenarios _(Defined, not coded yet)_

| Case                  | Response                  |
|-----------------------|---------------------------|
| Invalid JSON          | 400 Bad Request           |
| Missing title/content | 422 Unprocessable Entity  |
| Note not found        | 404 Not Found             |
| Server error          | 500 Internal Server Error |

These are **contracts**, not implementation details.

Backend owns **structure**. Frontend obeys.

### Why This Addition Is Architecturally Correct

âœ” Maintains **clear state transitions** <br>
âœ” Preserves **backend authority** <br>
âœ” Avoids frontend guesswork <br>
âœ” Prepares for failure training later _(Week 6)_

## 5ï¸âƒ£ Data Flow _(One Direction Only)_

Golden Rule:

> Data flows down. Events flow up.

```
User Action
   â†“
Frontend Controller
   â†“
API Client
   â†“
Backend
   â†“
Response
   â†“
State Update
   â†“
UI Render
```

ğŸš« No shortcut DOM updates <br>
ğŸš« No UI mutating data directly

This is **React thinking without React**.

## 6ï¸âƒ£ Internal Module Boundaries _(Mental Map)_

Youâ€™re not coding, but you must **see files in your head**.

### Frontend _(conceptual)_

```
/frontend
  â”œâ”€â”€ ui            â†’ render only
  â”œâ”€â”€ state         â†’ data only
  â”œâ”€â”€ api           â†’ fetch only
  â”œâ”€â”€ controller    â†’ glue logic
```

### Backend _(conceptual)_

```
/backend
  â”œâ”€â”€ server        â†’ HTTP only
  â”œâ”€â”€ routes        â†’ URL â†’ action
  â”œâ”€â”€ services      â†’ business logic
  â”œâ”€â”€ store         â†’ data storage
  â”œâ”€â”€ logger        â†’ observability
```

Each layer knows **only one layer below it**.

## 7ï¸âƒ£ Failure as a First-Class Citizen _(Preview)_

Even today, list what can break:

- Network timeout
- Invalid JSON
- Empty request body
- Server crash
- Partial response

We are **not fixing them today**, only acknowledging reality.

## 8ï¸âƒ£ Observability Philosophy _(Before Logs Exist)_

Define what must be observable later:

### Frontend:

- API call start
- API call end
- Failure reason

### Backend

- Incoming request
- Validation failure
- Processing time
- Crash cause

If something fails silently â†’ architecture failed.

## 9ï¸âƒ£ Day-1 Deliverables _(Non-Negotiable)_

By end of Day 1, you should have:

âœ… A hand-drawn or markdown architecture diagram <br>
âœ… A written data contract <br>
âœ… A list of API routes <br>
âœ… Clear ownership rules _(frontend vs backend)_ <br>
âœ… A sentence explaining data flow

If you canâ€™t explain this to someone else â€” **do not code tomorrow**.

## Final Thought _(Important)_

Most developers skip this day.
Thatâ€™s why their apps become unmaintainable.

Youâ€™re doing what **senior engineers do instinctively**.