# Day 1 â€” Architecture First _(No Coding)_

## Objectives

> Build a clear, explainable mental model of the Note-Taking App before touching the keyboard.

## 1ï¸âƒ£ Problem Definition _(Engineering, not features)_

**Problem statement _(strict)_:**

> A user can create, view, and delete notes. <br>
> Notes must survive frontend refresh. <br>
> System must tolerate bad inputs and unreliable network.

No UI fantasy. No styling talk. Only behavior.

## 2ï¸âƒ£ System Boundary Definition _(MOST IMPORTANT)_

Draw this line in your head ğŸ‘‡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend   â”‚  HTTP  â”‚    Backend    â”‚
â”‚  (Browser)   â”‚ <â”€â”€â”€>  â”‚   (Node.js)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Frontend is responsible for:

- User interaction
- Rendering notes
- Calling APIs
- Handling failures visually

### Backend is responsible for:

- Accepting requests
- Validating data
- Storing notes
- Returning responses

ğŸš« Frontend must **never**:

- Decide note IDs
- Assume data validity
- Guess backend state

ğŸš« Backend must **never**:

- Care about DOM
- Care about user clicks
- Assume UI correctness

This separation is sacred.

## 3ï¸âƒ£ Data Contract _(Single Source of Truth)_

This is the **contract**, not an implementation.

```js
Note {
  id: string,
  title: string,
  content: string,
  createdAt: number
}
```

### Rules:

- `id` generated by backend
- `createdAt` generated by backend
- Frontend treats notes as **immutable** snapshots

This avoids sync hell later.

## 4ï¸âƒ£ API Surface _(Minimal but Complete)_

We define **what exists**, not how itâ€™s coded.

| Method | Route      | Purpose                 |
| ------ | ---------- | ----------------------- |
| GET    | /notes     | Fetch all notes         |
| POST   | /notes     | Create a new note       |
| PUT    | /notes/:id | Update an existing note |
| DELETE | /notes/:id | Delete a note           |
| GET    | /health    | Server health check     |

### Example request _(POST /notes)_

```json
{
  "title": "Meeting Notes",
  "content": "Discussed architecture"
}
```

### Example response

```json
{
  "id": "n_123",
  "title": "Meeting Notes",
  "content": "Discussed architecture",
  "createdAt": 1700000000000
}
```

### ğŸ” Update Note â€” Contract Definition

Request

**PUT /notes/:id**

```json
{
  "title": "Updated meeting notes",
  "content": "Architecture finalized"
}
```

Rules:

- id comes only from URL
- Body contains only mutable fields
- Missing fields â†’ validation failure
- Partial updates are not allowed _(no PATCH yet)_

### Why PUT and not PATCH?

> Because this keeps state transitions **explicit and predictable** in a learning system.

### Response _(Success)_

```json
{
  "id": "n_123",
  "title": "Updated meeting notes",
  "content": "Architecture finalized",
  "createdAt": 1700000000000
}
```

Backend guarantees:

- `id` unchanged
- `createdAt` unchanged
- Full note returned _(single source of truth)_

### Failure Scenarios _(Defined, not coded yet)_

| Case                  | Response                  |
| --------------------- | ------------------------- |
| Invalid JSON          | 400 Bad Request           |
| Missing title/content | 422 Unprocessable Entity  |
| Note not found        | 404 Not Found             |
| Server error          | 500 Internal Server Error |

These are **contracts**, not implementation details.

Backend owns **structure**. Frontend obeys.

### Why This Addition Is Architecturally Correct

âœ” Maintains **clear state transitions** <br>
âœ” Preserves **backend authority** <br>
âœ” Avoids frontend guesswork <br>
âœ” Prepares for failure training later _(Week 6)_

## 5ï¸âƒ£ Data Flow _(One Direction Only)_

Golden Rule:

> Data flows down. Events flow up.

```
User Action
   â†“
Frontend Controller
   â†“
API Client
   â†“
Backend
   â†“
Response
   â†“
State Update
   â†“
UI Render
```

ğŸš« No shortcut DOM updates <br>
ğŸš« No UI mutating data directly

This is **React thinking without React**.

## 6ï¸âƒ£ Internal Module Boundaries _(Mental Map)_

Youâ€™re not coding, but you must **see files in your head**.

### Frontend _(conceptual)_

```
/frontend
  â”œâ”€â”€ ui            â†’ render only
  â”œâ”€â”€ state         â†’ data only
  â”œâ”€â”€ api           â†’ fetch only
  â”œâ”€â”€ controller    â†’ glue logic
```

### Backend _(conceptual)_

```
/backend
  â”œâ”€â”€ server        â†’ HTTP only
  â”œâ”€â”€ routes        â†’ URL â†’ action
  â”œâ”€â”€ services      â†’ business logic
  â”œâ”€â”€ store         â†’ data storage
  â”œâ”€â”€ logger        â†’ observability
```

Each layer knows **only one layer below it**.

## 7ï¸âƒ£ Failure as a First-Class Citizen _(Preview)_

Even today, list what can break:

- Network timeout
- Invalid JSON
- Empty request body
- Server crash
- Partial response

We are **not fixing them today**, only acknowledging reality.

## 8ï¸âƒ£ Observability Philosophy _(Before Logs Exist)_

Define what must be observable later:

### Frontend:

- API call start
- API call end
- Failure reason

### Backend

- Incoming request
- Validation failure
- Processing time
- Crash cause

If something fails silently â†’ architecture failed.

## 9ï¸âƒ£ Day-1 Deliverables _(Non-Negotiable)_

By end of Day 1, you should have:

âœ… A hand-drawn or markdown architecture diagram <br>
âœ… A written data contract <br>
âœ… A list of API routes <br>
âœ… Clear ownership rules _(frontend vs backend)_ <br>
âœ… A sentence explaining data flow

If you canâ€™t explain this to someone else â€” **do not code tomorrow**.

## Final Thought _(Important)_

Most developers skip this day.
Thatâ€™s why their apps become unmaintainable.

Youâ€™re doing what **senior engineers do instinctively**.

# Day 2 â€” Backend Skeleton

**Node.js Â· No frameworks Â· Reality-first**

## Objectives

> Build a minimal, observable HTTP server that you fully understand end-to-end.

## 0ï¸âƒ£ Ground Rules _(Read Before Coding)_

âŒ No Express / Fastify / frameworks <br>
âŒ No database <br>
âŒ No business logic yet <br>
âœ… Raw http module <br>
âœ… Manual routing <br>
âœ… Manual logging <br>
âœ… Explicit control over request & response

If something feels â€œverboseâ€, thatâ€™s the **point**.

## 1ï¸âƒ£ What We Are Building Today _(Scope Lock)_

By end of Day 2, backend will have:

- A running HTTP server
- One real route: `GET /health`
- One placeholder route: `GET /notes` â†’ returns `[]`
- A **manual logger**
- Clean separation:
  - HTTP layer
  - Routing
  - Logging

Nothing else

## 2ï¸âƒ£ Mental Model: What Happens on Every Request

Before code, internalize this:

```pgsql
Client
  â†“
TCP connection
  â†“
Node http server
  â†“
Request object (req)
  â†“
Your routing logic
  â†“
Response object (res)
  â†“
Serialized HTTP response
```

Node does **not**:

- Parse JSON automatically
- Route automatically
- Log automatically

You do everything.

## 3ï¸âƒ£ Folder Structure _(Minimal but Intentional)_

> commit hash **3a09b94**

Create this **exact structure**:

```pgsql
backend/
  â”œâ”€â”€ server.js
  â”œâ”€â”€ router.js
  â””â”€â”€ logger.js
```

Each file has **one responsibility**.

## 4ï¸âƒ£ logger.js â€” Observability Starts Here

> commit hash **287b26a**

> Logging is not debugging. <br>
> Logging is **system memory**.

```js
// logger.js

function log({ method, url, status, duration }) {
  const time = new Date().toISOString();

  console.log(`[${time}] ${method} ${url} ${status} ${duration}ms`);
}

module.exports = { log };
```

Why this shape?

- Structured
- Extendable
- No business coupling

## 5ï¸âƒ£ router.js â€” Manual Routing _(No Magic)_

> commit hash **87d846b**

> Routing is **just decision making**.

```js
// router.js

function router(req, res) {
  const { method, url } = req;

  if (method === "GET" && url === "/health") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ status: "ok" }));
    return;
  }

  if (method === "GET" && url === "/notes") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify([]));
    return;
  }

  // fallback
  res.writeHead(404, { "Content-Type": "application/json" });
  res.end(JSON.stringify({ error: "Not Found" }));
}

module.exports = { router };
```

Important:

- `return` after response â†’ **critical**
- Explicit headers â†’ no guessing
- No try/catch yet (we want it to break loudly)

## 6ï¸âƒ£ server.js â€” The HTTP Boundary

> commit hash **96f1b70**

This file **touches the network**. <br>
Everything else must stay pure.

```js
// server.js

const http = require("http");
const { router } = require("./router");
const { log } = require("./logger");

const PORT = 3000;

const server = http.createServer((req, res) => {
  const start = Date.now();

  res.on("finish", () => {
    const duration = Date.now() - start;

    log({
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration,
    });
  });

  router(req, res);
});

server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
```

Key ideas here:

- `res.on('finish')` â†’ **true response lifecycle**
- Logging happens after response is sent
- Server knows nothing about routes

This is **clean separation**.

## 7ï¸âƒ£ Test Like an Engineer _(Not a Coder)_

Use browser or curl.

### Health check

```bash
GET http://localhost:3000/health
```

Response:

```json
{ "status": "ok" }
```

Log:

```bash
[2026-01-19T15:12:01.234Z] GET /health 200 1ms
```

### Notes

```bash
GET http://localhost:3000/notes
```

Response:

```json
[]
```

### Invalid route

```bash
GET /random
```

response:

```json
{ "error": "Not Found" }
```

## 8ï¸âƒ£ What You Must _Feel_ After Day 2

If Day 2 worked correctly, you should now:

- Understand **how Express works internally**
- Know where latency is measured
- Know who controls headers & status codes
- Realize how much magic frameworks hide

If you donâ€™t feel this yet â†’ reread and retype manually.

## 9ï¸âƒ£ Common Mistakes _(Avoid These)_

âŒ Putting logic in `server.js` <br>
âŒ Logging before response finishes <br>
âŒ Forgetting `return` after `res.end()` <br>
âŒ Assuming JSON parsing exists <br>
âŒ Adding POST logic today (too early)

## 1ï¸âƒ£0ï¸âƒ£ Day 2 Exit Criteria _(Hard Check_)

You are allowed to proceed only if:

- You can explain every line in `server.js`
- You know why `res.on('finish')` is used
- You can add a new route **without copying blindly**
- Logs make sense without reading code
